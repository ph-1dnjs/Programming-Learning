# 이벤트<br>  
  
## 이벤트 드리븐 프로그래밍<br>  
---  
> 애플리케이션이 특정 타입의 이벤트에 대해 반응하여 어떤 일을 하고 싶다면 해당하는 타입의 이벤트가 발생했을 때 호출될 함수를 브라우저에게 알려 호출을 위임한다.  
  
  
`이벤트 핸들러`: 이벤트가 발생했을 때 호출될 함수  
`이벤트 핸들러 등록`: 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것  
  
  
  
## 이벤트 타입<br>  
---  
> 이벤트 타입은 이벤트의 종류를 나타내는 문자열이다.  약 200여 가지가 존재한다.  
  
  
  
  
### 마우스 이벤트<br>  
|이벤트 타입|이벤트 발생 시점|  
|:---|:---|
|click|마우스 버튼을 클릭했을 때|  
|dbclick|마우스 버튼을 더블 클릭했을 때|  
|mousedown|마우스 버튼을 눌렀을 때|  
|mouseup|누르고 있던 마우스 버튼을 놓았을 때|  
|mousemove|마우스 커서를 움직였을 때|  
|mouseenter|마우스 커서를 HTML 요소 안으로 이동했을 때<br>(버블링 되지 않는다)|  
|mouseover|마우스 커서를 HTML 요소 안으로 이동했을 때<br>(버블링된다)|  
|mouseleave|마우스 커서를 HTML 요소 밖으로 이동했을 때<br>(버블링 되지 않는다)|  
|mouseout|마우스 커서를 HTML 요소 밖으로 이동했을 때<br>(버블링된다)|  
  
### 키보드 이벤트<br>  
|이벤트 타입|이벤트 발생 시점|  
|:---|:---|
|keydown|모든 키를 눌렀을 때 발생한다.<br>🚨 control, option, shift, tab, delete, enter, 방향 키와 문자, 숫자, 특수 문자 키를 눌렀을 때 발생한다. 단, 문자, 숫자, 특수 문자, enter 키를 눌렀을 때는 연속적으로 발생하지만 그 외의 키를 눌렀을 때는 한 번만 발생한다. |  
|keypress|문자 키를 눌렀을 때 연속적으로 발생한다.<br>🚨 control, option, shift, tab, delete, 방향 키 등을 눌렀을 때는 발생하지 않고 문자, 숫자, 특수 문자, enter 키를 눌렀을 때만 발생한다. 폐지되었으므로 사용하지 않을 것을 권장한다.|  
|keyup|누르고 있던 키를 놓았을 때 한 번만 발생한다.<br>🚨 keydown 이벤트와 마찬가지로 control, option, shift, tab, delete, enter, 방향 키와 문자, 숫자, 특수 문자 키를 놓았을 때 발생한다.|  
  
### 포커스 이벤트<br>  
|이벤트 타입|이벤트 발생 시점|  
|:---|:---|
|focus|HTML 요소가 포커스를 받았을 때(버블링되지 않는다)|  
|blur|HTML 요소가 포커스를 받았을 때(버블링되지 않는다)|  
|focusin|HTML 요소가 포커스를 받았을 때(버블링된다)|  
|focusout|HTML 요소가 포커스를 받았을 때(버블링된다)|  
🚨 `focusin`, `focusout` 이벤트 핸들러는 프로퍼티 방식으로 등록했을 때 크롬, 사파리에서 정상 동작 하지 않는다. → `addEventListener` 메서드 방식을 사용해 등록해야 함.  
  
### 폼 이벤트<br>  
|이벤트 타입|이벤트 발생 시점|  
|:---|:---|
|submit|1. form 요소 내의 input(text, checkbox, radio), select 입력 필드(textarea 제외)에서 엔터키를 눌렀을 때<br>2. form 요소 내의 submit 버튼(<button>, <input type=”submit”>)을 클릭했을 때<br>🚨 submit 이벤트는 form 요소에서 발생한다.|  
|reset|form 요소 내의 reset 버튼을 클릭했을 때(최근에는 사용 안 함)|  
  
### 값 변경 이벤트<br>  
|이벤트 타입|이벤트 발생 시점|  
|:---|:---|
|input|input(text, checkbox, radio), select, textarea 요소의 값이 입력되었을 때|  
|change|input(text, checkbox, radio), select, textarea 요소의 값이 변경되었을 때<br>🚨 change 이벤트는 input 이벤트와 달리 HTML 요소가 포커스를 잃었을 때 사용자 입력이 종료되었다고 인식하여 발생한다. 즉, 사용자가 입력을 하고 있을 때는 input 이벤트가 발생하고 사용자 입력이 종료되어 값이 변경되면 change 이벤트가 발생한다.|  
|readystatechange|HTML 문서의 로드와 파싱 상태를 나타내는 document.readyState 프로퍼티의 값(’loading’, ‘interactive’, ‘complete’)이 변경될 때|  
  
### DOM 뮤테이션 이벤트<br>  
|이벤트 타입|이벤트 발생 시점|  
|:---|:---|
|DOMContentLoaded|HTML 문서의 로드와 피싱이 완료되어 DOM 생성이 완료되었을 때|  
  
### 뷰 이벤트<br>  
|이벤트 타입|이벤트 발생 시점|  
|:---|:---|
|resize|브라우저 윈도우의 크기를 리사이즈할 때 연속적으로 발생한다.<br>🚨 오직 window 객체에서만 발생한다.|  
|scroll|웹페이지(document) 또는 HTML 요소를 스크롤할 때 연속적으로 발생한다.|  
  
### 리소스 이벤트<br>  
|이벤트 타입|이벤트 발생 시점|  
|:---|:---|
|load|DOMContentLoaded 이벤트가 발생한 이후, 모든 리소스의 로딩이 완료되었을 때|  
|unload|리소스가 언로드될 때|  
|abort|리소스 로딩이 중단되었을 때|  
|error|리소스 로딩이 실패했을 때|  
  
## 이벤트 핸들러 등록<br>  
---  
> 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다. 이벤트 핸들러를 등록하는 방법은 3가지다.  
  
  
### 이벤트 핸들러 어트리뷰트 방식<br>  
이벤트 핸들러 어트리뷰트 값으로 함수 호출문 등의 문을 할당하면 이벤트 핸들러가 등록 된다.  
  
```javascript  
<button onclick="alert('Hi!')">Click me!</button>  
```  
  
### 이벤트 핸들러 프로퍼티 방식<br>  
이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록된다.  
  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/18e2807b-cf7d-4462-bda9-6162643d65ec-스크린샷_2025-04-06_오후_10.46.55.png)  
  
`이벤트 핸들러 어트리뷰트 방식`도 결국 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 결과적으로 `이벤트 핸들러 프로퍼티 방식`과 동일하다고 할 수 있다.  
  
* HTML과 자바스크립트가 뒤섞이는 문제를 해결할 수 있다. `장점`  
* 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩 할 수 있다. `단점`  
  
```html  
<!DOCTYPE html>
<html>
<body>
	<button>Click me!</button>
</body>
<script>
	const $button = document.querySelector('button');
	
	// 이벤트 핸들러 프로퍼티 방식은 하나의 이벤트에 하나의 이벤트 핸들러만을 바인딩할 수 있다.
	// 첫 번째로 바인딩된 이벤트 핸들러는 두 번째 바인딩된 이벤트 핸들러에 의해 재할당되어 실행되지 않는다.
	$button.onclick = function () {
		console.log('Button clicked 1');
	};
	
	$button.onclick = function () {
		console.log('Button clicked 2');
	};
</script>
</html>  
```  
  
### addEventListener 메서드 방식<br>  
`EventTarget.prototype.addEventListener` 메서드를 사용하여 이벤트 핸들러를 등록할 수 있다.  
  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/6715e05d-9da7-4098-b282-d94204f45cbe-스크린샷_2025-04-06_오후_10.59.07.png)  
  
* 이벤트 핸들러 프로퍼티 방식과 달리 on 접두사를 붙이지 않는다.  
* 이벤트를 캐치할 이벤트 전파 단계(캡처링 또는 버블링)를 지정한다.  
  
```html  
<!DOCTYPE html>
<html>
<body>
	<button>Click me!</button>
</body>
<script>
	const $button = document.querySelector('button');
	
	// 이벤트 핸들러 프로퍼티 방식
	// $button.onclick = function () {
	//   console.log('button click');
	// };
	
	// addEventListener 메서드 방식
	$button.addEventListener('click', function () {
		console.log('button click');
	});
</script>
</html>  
```  
`이벤트 핸들러 프로퍼티 방식`은 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩하지만 `addEventListener 메서드`에는 이벤트 핸들러를 인수로 전달한다.  
  
  
  
* addEventListener 메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있다. (등록된 순서대로 호출)  
* 단, 참조가 동일한 이벤트 핸들러를 중복 등록하면 하나의 이벤트 핸들러만 등록 된다.  
  
## 이벤트 핸들러 제거<br>  
---  
> addEventListener 메서드로 등록한 이벤트 핸들러를 제거하려면 EventTarget.prototype.removeEventLister 메서드를 사용한다.  
  
  
  
  
무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다.  
```javascript  
// 이벤트 핸들러 등록
$button.addEventListener('click', () => console.log('button click'));
// 등록한 이벤트 핸들러를 참조할 수 없으므로 제거할 수 없다.  
```  
  
기명 이벤트 핸들러 내부에서 이벤트 핸들러를 제거하는 것은 가능하다.  
```javascript  
// 기명 함수를 이벤트 핸들러로 등록
$button.addEventListener('click', function foo() {
	console.log('button click');
	// 이벤트 핸들러를 제거한다. 따라서 이벤트 핸들러는 단 한번만 호출된다.
	$button.removeListener('click', foo);
});  
```  
  
자기 자신을 가리키는 arguments.callee를 사용할 수도 있다.  
```javascript  
// 무명 함수를 이벤트 핸들러로 등록
$button.addEventListener('click', function () {
	console.log('button click');
	// 이벤트 핸들러를 제거한다. 따라서 이벤트 핸들러는 단 한번만 호출된다.
	// arguments.callee는 호출된 함수, 즉 함수 자신을 가리킨다.
	$button.removeListener('click', arguments.callee);
});  
```  
  
  
  
## 이벤트 객체<br>  
---  
> 이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다. 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.  
  
  
```javascript  
const $msg = document.querySelector('.message');

// 클릭 이벤트에 의해 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.
function showCoords(e) {
	$msg.textContent = `clientX: ${e.clientX}, clientY ${e.clientY}`;
}  
```  
  
* 이벤트 핸들러 어트리뷰트 방식의 경우 이벤트 객체를 전달받으려면 이름이 반드시 `event`이어야 한다.  
  
### 이벤트 객체의 상속 구조<br>  
> 이벤트가 발생하면 이벤트 타입에 따라 다양한 이벤트 객체가 생성된다.   
  
  
이벤트 객체는 다음과 같은 상속 구조를 갖는다.  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/5fee702e-3d39-48b5-b3e2-3c7164fcb37f-79e0746a-e2bc-46b7-9032-3cb4cf772c4c.png)  
  
### 이벤트 객체의 공통 프로퍼티<br>  
Event 인터페이스의 이벤트 관련 프로퍼티는 모든 이벤트 객체가 상속받는 공통 프로퍼티다.  
  
이벤트 객체의 공통 프로퍼티는 다음과 같다.  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/1ed802bb-1e8c-4064-82ba-a7129a1a5148-image.png)  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/8fb1d6d7-fb8f-483c-91ec-2f3256929cb1-image.png)  
  
### 마우스 정보 취득<br>  
`MouseEvent` 타입의 이벤트 객체는 다음과 같은 고유의 프로퍼티를 갖는다.  
* 마우스 포인터의 좌표 정보를 나타내는 프로퍼티 : screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY  
*  버튼 정보를 나타내는 프로퍼티 : altKey, ctrlKey, shiftKey, button  
  
### 키보드 정보 취득<br>  
KeyboardEvent 타입의 이벤트 객체는 altKey, ctrlKey, shiftKey, metaKey, key, keyCode 같은 고유의 프로퍼티를 갖는다.  
