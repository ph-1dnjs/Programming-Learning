# 데이터 타입<br>  
> 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 7개의 타입은 원시 타입과 객체타입으로 분류할 수 있다.  
  
  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/1d5e40e3-26da-4f44-a0f3-771c65f40dab-image.png)  
  
데이터 타입들은 값을 생성한 목적과 용도가 다르며, 확보해야할 메모리 공간의 크기도 다르고 메모리에 저장되는 2진수도 다르며 읽어 들여 해석하는 방식도 다르다.  
  
  
  
<ins>숫자와 문자열</ins> 같은 원시 타입은 **불변**(immutable)하다. <ins>객체 타입</ins>은 **변경 가능**(mutable)한 값들이다.   
  
## 불변성 Immutability<br>  
---  
자바스크립트에서 불변성이란 객체가 생성된 이후 그 상태를 변경할 수 없는 것을 의미한다. 여기서 상태를 변경할 수 있는 것과 값을 재할당하는 것은 다르다.  
  
```javascript  
let a = 10;
let b = a;
a = 20;
console.log(a, b);  
```  
위의 코드는 a에 10을 할당하고 b를 a가 가리키는 주소를 참조하고  
이때 a의 값을 20으로 변경했다.  
값을 직접 변경하는 것이라면 a와 b 모두 20을 출력해야한다.  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/06f85546-4b11-46b3-9b4d-acfdcb051795-image.png)  
하지만 자바스크립트 에서는 `Number`값은 불변성을 유지하기 때문에 새롭게 20이라는 값을 가지는 주소를 a에 할당하게 되기 때문에 위와 같은 결과가 나오게 된다.  
  
## 숫자 타입<br>  
---  
💡 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.  
  
숫자 타입의 값은 **배정밀도 64비트 부동소수점 형식**을 따른다. 즉, 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.  
  
```javascript  
var integer = 10;   // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수  
```  
  
정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소숫점 형식의 **2진수로 저장**된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 **10진수로 해석**된다.  
  
```javascript  
var binary = 0b01000001; // 2진수
var octal = 0o101;       // 8진수
var hex = 0x41;          // 16진수

// 표기법만 다를 뿐 모두 같은 값이다.
console.log(binary);          // 65
console.log(octal);           // 65
console.log(hex);             // 65
console.log(binary === octal) // true
console.log(octal === hex)    // true  
```  
  
자바스크립트 숫자 타입은 모든 수를 실수로 처리하기 때문에, 정수로 표시된다 해도 사실은 실수라는 것을 의미한다. 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.  
  
```javascript  
console.log(1 === 1.0); // true
console.log(4 / 2);     // 2
console.log(3 / 2);     // 1.5  
```  
  
세 가지 특별한 숫자 타입  
* Infinity: 양의 무한대  
* -Infinity: 음의 무한대  
* NaN: 산술 연산 불가(not-a-number)  
  
```javascript  
// 숫자 타입의 세가지 특별한 값
console.log(10 / 0);       // Infinity
console.log(10 / -0);      // -Infinity
console.log(1 * 'String'); // NaN  
```  
  
```javascript  
// 자바스크립트는 대소문자를 구별한다. case-sensitive
var x = nan; // ReferenceError: nan is not defined  
```  
  
## 문자열 타입<br>  
---  
문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할 수 있다. 문자열은 작은따옴표(’ ’), 큰따옴표(” “), 또는 백틱(` `)으로 텍스트를 감싼다.   
  
```javascript  
// 문자열 타입
var string;
string = '문자열'; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱(ES6)  
```  
  
💡 자바스립트에서 가장 일반적인 표기법은 작은따옴표를 사용하는 것이다.  
  
```javascript  
string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";  
```  
  
다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위함이다. 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식한다.  
  
```javascript  
// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.
var string = hello; // ReferenceError: hello is not defined  
```  
  
만약 따옴표로 문자열을 감싸지 않는다면 스페이스와 같은 공백 문자도 포함시킬 수 없다.  
  
## 템플릿 리터럴<br>  
---  
ES6부터 템플릿 리터럴이라고 하는 새로문 문자열 표기법이 도입되었다. 템플릿 리터럴은 **백틱(` `)**을 사용해 표현한다.  
  
### 멀티라인 문자열<br>  
  
```javascript  
var str = 'hello
world.';
// SyntaxError: Invalid or unexpected token  
```  
  
일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다. 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용해야 한다.  
  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/80f18807-2aaa-4ac9-800a-68bad1ac3066-image.png)  
  
이스케이프 시퀀스 사용 예시  
```javascript  
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n<ul>';
console.log(template);

// <ul>
//   <li><a href="#">Home</a></li>
// </ul>  
```  
  
일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.  
  
```javascript  
var template = `<ul>
	<li><a href="#">Home</a><li>
</ul>`;
console.log(template);

// <ul>
//   <li><a href="#">Home</a></li>
// </ul>  
```  
  
### 표현식 삽입<br>  
문자열은 문자열 연산자 `+`를 사용해 연결할 수 있다. `+`연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다.   
  
```javascript  
var first = 'Ung-mo';
var last = 'Lee';

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.'); // My name is Ung-mo Lee.  
```  
  
탬플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있다. 이를 토앻 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있다.  
  
```javascript  
 var first = 'Ung-mo';
 var last = 'Lee';
 
 // ES6: 표현식 삽입
 console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.  
```  
  
표현식을 삽입하려면 `${}`으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다.  
  
## 불리언 타입<br>  
---  
불리언 타입의 값은 논리적 참, 거짓을 나타내는 `true`와 `false`뿐이다.  
  
```javascript  
var foo = true;
console.log(foo); // true

foo = false;
console.log(foo); // false  
```  
  
불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용한다.  
  
## undefined 타입<br>  
---  
undefined를 직역하면 “정의되지 않은”이다. 자바스크립트의 undefined에서 말하는 정의란 변수에 값을 할당하여 변수의 실체를 명확히 하는 것을 말한다.  
  
`undefined`는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이다. 변수를 참조했을 때 `undefined`가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는, 즉 초기화되지 않은 변수라는 것을 간파할 수 있다.  
  
  
  
## null 타입<br>  
---  
프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재)할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다.  
  
💡 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.  
  
```html  
<!DOCTYPE html>
<html>
<body>
	<script>
		var element = document.querySelector('.myClass');
		
		// HTML 문서에 myClass 클래스를 갖는 요소가 없다면 null을 반환한다.
		console.log(element); // null
	</script>
</body>
</html>  
```  
  
## 심벌 타입<br>  
---  
심벌은 ES6에 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.  
  
심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 `Symbol` 함수를 호출해 생성한다. 이때 생성된 심벌값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다. 따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.  
  
```java  
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value  
```  
  
## 객체 타입<br>  
---  
자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체다. 즉, 6가지 데이터 타입 이외의 값은 모두 객체 타입이다.  
  
## 데이터 타입의 필요성<br>  
---  
  
### 데이터 타입에 의한 메모리 공간의 확보와 참조<br>  
> 값은 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.  
  
  
```java  
var score = 100;  
```  
  
자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.  
  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/840a2fe0-4803-4137-8820-725dc45f84a3-image.png)  
  
  
  
값을 참조하는 경우에는 한 번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야 한다.  
  
### 데이터 타입에 의한 값의 해석<br>  
> 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트 나열로 저장된다.  
  
  
메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.  
|메모리에 저장된 값|0100 0001|  
|:---|:---|
|숫자 해석|65|  
|문자열 해석|‘A'|  
  
### 정리<br>  
* 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해  
* 값을 참조할 때 한 번에 읽어 들여야 할** 메모리 공간의 크기**를 결정하기 위해  
* 메모리에서 읽어 들인** 2진수를 어떻게 해석**할지 결정하기 위해  
  
## 동적 타이핑<br>  
---  
  
### 동적 타입 언어와 정적 타입 언어<br>  
C나 Java같은** 정적 타입 언어**는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 **명시적 타입 선언**이라 한다.  
  
**정적 타입 언어**  
* 변수의 선언 시점에 변수의 타입이 결정된다.  
* 변수의 타입을 변경할 수 없다.  
* 컴파일 시점에 **타입 체크**를 수행하여 통과하지 못하는 경우 에러를 발생시키고 프로그램의 실행을 막는다.  
* 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다.  
  
자바스크립트는** 동적 타입 언어**  
* 변수를 선언할 때 타입을 선언하지 않는다.   
* 다만 `var`, `let`, `const`키워드를 사용해 변수를 선언한다.  
* 값을 할당하는 시점에 변수의 타입이 동적으로 결정된다.  
* 미리 선언한 데이터 타입의 값 뿐만 아닌 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.  
  
  
  
**정리**  
자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.  이러한 특징을 **동적 타이핑**이라 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 **동적 타입 언어**라 한다.  
  
### 동적 타입 언어와 변수<br>  
> 동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.  
  
  
**동적 타입 언어의 구조적 단점**  
변수의 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어렵다. 타입이 변경될 수 있다는 유연성 때문에 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.  
  
**변수를 사용할 때 주의사항**  
* 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 변수의 무분별한 남발은 금물이며, 필요한 만큼 최소한으로 유지하도록 주의해야한다.  
* 변수의 유효 범위는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.  
* 전역 변수는 최대한 사용하지 않도록 한다. 전역 변수는 프로그램의 복잡성을 증가시키고, 처리흐름을 추적하기 어렵게 만들고, 오류가 발생할 경우 오류의 원인을 특정하기 어렵게 만든다.  
* 변수보다는 상수를 사용해 값의 변경을 억제한다.  
* 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.  
  
