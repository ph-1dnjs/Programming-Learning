## 변수란 무엇인가? 왜 필요한가?<br>  
---  
컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.  
  
메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는** 1바이트(8비트)**이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어들인다.   
  
```javascript  
10 + 20  
```  
  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/8954bd83-f276-4c73-a1dd-81023bdcc403-image.png)  
  
각 셀은 고유의 메모리 주소를 갖는다. 이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현된다. 4GB 메모리는 0부터 4,294,967,295 (0x00000000 ~ 0xFFFFFFFF)까지의 메모리 주소를 갖는다.  
  
  
  
  
  
프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.  
  
**변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.**  
  
변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다. 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 접근할 수 있다.  
  
<details><summary>변수에 여러개의 값을 저장하는 방법</summary>  
  
  ```javascript  
// 변수는 하나의 값을 저장하기 위한 수단
var userId = 1;
var userName = 'Lee';

// 객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화 해서 하나의 값처럼 사용 가능
var user = { id: 1, name: 'Lee' };

var users = [
   { id: 1, name: 'Lee' }.
   { id: 2, name: 'Kim' }
];  
```  
</details>  
  
```javascript  
var result = 10 + 20; // result 변수 이름(식별자)  
```  
연산을 통해 새로운 값을 메모리 공간에 저장된다. 이때 메모리 공간에 저장된 값 30을 다시 읽어들여 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인 것이 바로 변수다.  
  
  
  
## 식별자<br>  
---  
변수 이름을 식별자라고도 한다. **식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.   
**식별자는 값이 저장되어있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야한다.  
  
  
  
식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미다. 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.  
  
👉 변수 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.  
  
**식별자 규칙**  
* 식별자는 반드시 글자나 달러 기호($), 밑줄(_)로 시작해야한다.  
* 식별자에는 글자와 숫자, 달러 기호, 밑줄만 쓸 수 있다.  
* π나 ö 같은 유니코드 문자도 쓸 수 있다.  
* 예약어는 식별자로 쓸 수 없다.   
  
<details><summary>📍** 자바스크립트 예약어 목록**</summary>  
  
  |예약어|설명|  
|:---|:---|
|`await`|`async` 함수 내에서 비동기 코드 실행 대기|  
|`break`|루프나 `switch` 문을 종료|  
|`case`|`switch` 문에서 특정 조건을 정의|  
|`catch`|`try`...`catch`에서 예외 처리|  
|`class`|클래스를 정의|  
|`const`|변경할 수 없는 변수를 선언|  
|`continue`|루프에서 다음 반복으로 건너뜀|  
|`debugger`|코드 실행을 디버깅 모드에서 중단|  
|`default`|`switch` 문에서 기본 실행 블록 정의|  
|`delete`|객체의 속성을 제거|  
|`do`|`do...while` 루프 시작|  
|`else`|`if` 문에서 조건이 거짓일 때 실행되는 블록 정의|  
|`enum`|열거형을 정의 (미래 예약어)|  
|`export`|모듈을 내보냄|  
|`extends`|클래스를 상속받을 때 사용|  
|`false`|불리언 `false` 값|  
|`finally`|`try...catch`에서 항상 실행되는 블록|  
|`for`|`for` 반복문 시작|  
|`function`|함수를 선언|  
|`if`|조건문을 정의|  
|`import`|모듈을 불러옴|  
|`in`|객체의 속성을 검사하거나 `for...in` 루프에서 사용|  
|`instanceof`|객체가 특정 클래스의 인스턴스인지 확인|  
|`new`|객체의 새 인스턴스를 생성|  
|`null`|`null` 값 (값이 없음)|  
|`return`|함수에서 값을 반환|  
|`super`|부모 클래스의 생성자를 호출하거나 속성에 접근|  
|`switch`|여러 경우(case)를 처리하는 조건문|  
|`this`|현재 객체를 참조|  
|`throw`|예외를 발생|  
|`true`|불리언 `true` 값|  
|`try`|예외 처리를 위한 코드 블록 시작|  
|`typeof`|값의 타입을 반환|  
|`var`|변수를 선언 (ES6 이후 `let`, `const` 권장)|  
|`void`|표현식의 결과를 반환하지 않음|  
|`while`|`while` 루프 시작|  
|`with`|객체의 속성을 보다 간결하게 참조 (사용 비추천)|  
|`yield`|제너레이터 함수에서 값을 반환하고 실행 중지|  
  
📍 추가적으로, 자바스크립트에서 **식별자로 사용할 수 없는 일부 미래 예약어**  
|미래 예약어|설명|  
|:---|:---|
|`implements`|인터페이스 구현 (Java 스타일)|  
|`interface`|인터페이스 선언|  
|`package`|패키지 정의 (Java 스타일)|  
|`private`|클래스 내부 전용 멤버 선언 (ES 제안)|  
|`protected`|보호된 멤버 선언 (ES 제안)|  
|`public`|공개 멤버 선언 (ES 제안)|  
|`static`|정적 멤버 선언|  
  
</details>  
  
**식별자 표기 방식**  
|표기법|설명|예시|  
|:---|:---|:---|
|**카멜 케이스**** camelCase**|- 단어를 소문자로 시작하고 이후 단어는 대문자로 시작  - 일반적인 변수 및 함수명에 사용|`myVariablegetUserInfo()`|  
|**파스칼 케이스**** PascalCase**|- 모든 단어의 첫 글자를 대문자로 작성  - 클래스 및 생성자 함수명에 사용|`MyClassUserProfile`|  
|**스네이크 케이스**** snake_case**|- 모든 문자를 소문자로 하고, 단어 사이를 밑줄(_)로 구분  - 데이터베이스 필드명, 일부 환경 변수에서 사용|`my_variableuser_profile`|  
|**SCREAMING_SNAKE_CASE**|- `snake_case`와 동일하지만 모든 문자를 대문자로 작성  - 상수 선언 시 사용|`MAX_VALUEAPI_KEY`|  
|**케밥 케이스 ****kebab-case**|- 모든 문자를 소문자로 하고, 단어 사이를 하이픈(-)으로 구분  - 파일명, CSS 클래스명에서 주로 사용 (자바스크립트 변수명으로 사용 불가)|`my-variable.jsuser-profile`|  
|**Hungarian Notation**|- 변수명 앞에 자료형 접두어를 붙이는 방식  - 오래된 스타일이며 현대 JS에서는 잘 사용되지 않음|`strName` (string)`intAge` (integer)|  
|**m_ 접두어**|- 클래스의 멤버 변수(인스턴스 변수)를 구분하기 위해 접두어 `m_`을 붙이는 방식|`m_namem_age`|  
|**_underscorePrefix**|- `_`를 앞에 붙여 **비공개(private) 변수**임을 암시  - 공식적인 접근 제한자는 아니지만, 관례적으로 사용|`_privateVar_hiddenMethod()`|  
  
## 변수 선언<br>  
---  
변수 생성, 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.  
  
  
  
```javascript  
var score; // 변수 선언 (변수 선언문)  
```  
  
변수를 선언한 이후, 아직 변수에 값을 할당하지 않았다. 확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined라는 값이 암묵적인 초기화로 할당된다. 자바스크립트의 독특한 특징  
  
***초기화**: 변수가 선언된 후 최초로 값을 할당하는 것을 말한다.  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/0fb86ca4-66df-438b-b708-785e119bb7b7-image.png)  
  
자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다.  
* 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.  
* 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.  
  
## 변수 선언의 실행 시점과 변수 호이스팅<br>  
---  
자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 전 소스코드의 평가 과정을 거치면서 소스코드 실행을 위한 준비를 한다.  
  
  
  
🤔 순차적으로 실행하게 되면  아래 코드는 에러가 날까?  
```javascript  
console.log(score); // undefined

var score; // 변수 선언문  
```  
  
자바스크립트 엔진은 변수 선언이 소스코드 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅****Variable hoisting**이라 한다.  
  
  
  
## 값의 할당<br>  
---  
변수에 값을 할당assignment 할 때는 할당 연산자 `=` 를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.  
  
```javascript  
var score; // 변수 선언
score = 80; // 값의 할당  
```  
  
```javascript  
var score = 80; // 변수 선언과 값의 할당 (단축 표현)  
```  
  
위 두가지 코드는 정확히 동일하게 동작한다. 즉, 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.  
  
  
  
```javascript  
console.log(score); // undefined

var score; // 변수 선언
score = 80; // 값의 할당

console.log(score); // 80  
```  
  
위 코드는 아래코드와 동일하게 동작한다.  
  
```javascript  
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당

console.log(score); // 80  
```  
  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/5c5bf500-3f79-4944-a4c3-088c476b3a6a-image.png)  
  
변수에 값을 할당할  때는 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다.  
  
아래 코드의 실행 결과는 무엇일까?  
```javascript  
console.log(score)

score = 80
var score

console.log(score)  
```  
  
## 값의 재할당<br>  
---  
재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.  
  
```javascript  
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당  
```  
  
변수는 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이다.  
  
만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다. 상수는 한번 정해지면 변하지 않는 값이다. 즉, 상수는 단 한 번만 할당할 수 있는 변수다  
  
![IMAGE](https://raw.githubusercontent.com/nogi-bot/resources/main/ph-1dnjs/images/290ded60-3c7f-45f1-85aa-647662e130df-image.png)  
  
이전 값은 어떤 변수고 값으로 갖고 있지 않다. 다시 말해 어떤 식별자와도 연결되어 있지 않다. 이러한 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될지는 예측할 수 없다.  
  
  
  
